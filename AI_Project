


from json.encoder import INFINITY
from queue import Empty

def ReadIn(filename): #Takes an input file, and process the data into a list of number   
    f = open(filename, 'r')
    matrix = []
    for line in f:
        line = line.strip()
        nums = line.split(' ')
        if len(nums) < 3:
            continue
        for i in range(3):
            nums[i] = int(nums[i])
            matrix.append(nums[i])
    curr_state = []
    goal_state = []
    for i in range(18):
        if i<9:
            curr_state.append(matrix[i])
        else:
            goal_state.append(matrix[i])

    return curr_state, goal_state


def MDistance(curr_state, goal_state):  # find the sum of manhattan distance of the node from
    # current 
    # `1`1state to goal state
    distance = 0
    for i,item in enumerate(curr_state): 
        if item != 0:
            curr_row,curr_col = int(i/ 3) , i % 3
            goal_row,goal_col = int(goal_state.index(item) /3),goal_state.index(item) % 3
            distance += abs(curr_row-goal_row) + abs(curr_col - goal_col)
    return distance

def NScore(curr_state, goal_state):
    P = MDistance(curr_state,goal_state)
    S = 0
    Nscore = 0
    order = [0,1,2,5,8,7,6,3]
    if curr_state[4] != goal_state[4]:
        S += 1
    for num in order:
        if (curr_state[num] != 0):
            if (curr_state[num] != goal_state[num]):
                S += 2
    Nscore = P + 3 * S
    return Nscore




def Asearch(h, curr_state, goal_state,goalReached=False,step_cost=0):
    state_space = [];  #This makes sure there is no repeated states.  
    frontier = []
    solution = []
    po = False
    while goalReached == False :
        if not curr_state in state_space:
            state_space.append(curr_state)
        blank_pos = curr_state.index(0)
        if blank_pos in [1,2,4,5,7,8]: #Check for the possibility of moving blank space to the left
            potential_state = curr_state.copy()
            potential_state[blank_pos-1],potential_state[blank_pos] = potential_state[blank_pos], potential_state[blank_pos-1]
            if potential_state not in state_space:
                if (h == "MD"):
                    hVal = MDistance(curr_state,goal_state)
                else:
                    hVal = NScore(curr_state,goal_state)
                frontier.append(['L', potential_state,hVal+step_cost])
                state_space.append(potential_state)
                po = True
            
        if blank_pos in [0,1,3,4,6,7]: #Check for the possibility of moving blank space to the right
            potential_state = curr_state.copy()
            potential_state[blank_pos+1],potential_state[blank_pos] = potential_state[blank_pos], potential_state[blank_pos+1]
            if potential_state not in state_space:
                if (h == "MD"):
                    hVal = MDistance(curr_state,goal_state)
                else:
                    hVal = NScore(curr_state,goal_state)

                frontier.append(['R', potential_state,hVal+step_cost])
                state_space.append(potential_state)
                po = True
        if blank_pos in [0,1,2,3,4,5]: #Check for the possibility of moving blank space to below
            potential_state = curr_state.copy()
            potential_state[blank_pos+3],potential_state[blank_pos] = potential_state[blank_pos], potential_state[blank_pos+3]
            if potential_state not in state_space:
                if (h == "MD"):
                    hVal = MDistance(curr_state,goal_state)
                else:
                    hVal = NScore(curr_state,goal_state)
                frontier.append(['D', potential_state,hVal+step_cost])
                state_space.append(potential_state)
                po = True
        if blank_pos in [3,4,5,6,7,8]: #Check for the possibility of moving blank space to above
            potential_state = curr_state.copy()
            potential_state[blank_pos-3],potential_state[blank_pos] = potential_state[blank_pos], potential_state[blank_pos-3]
            if potential_state not in state_space:
                if (h == "MD"):
                    hVal = MDistance(curr_state,goal_state)
                else:
                    hVal = NScore(curr_state,goal_state)
                frontier.append(['U', potential_state,hVal+step_cost])
                state_space.append(potential_state)
                po = True
                
        if(po == False):
            if curr_state in solution:
                solution.remove(curr_state)
                curr_state = solution[-1]
                step_cost -= 1
        print("FRONT",frontier)
         
        if (len(solution)!=0):
            min_fVal = solution[-1][2]
        for item in frontier:           #the state with minimum f value becomes current state
            min_fVal = frontier[0][2]
            
            if item[2] <= min_fVal:
                min_fVal = item[2]
                node = item             #store the node with smallest f value
                
            if (item == frontier[-1]):
                curr_state = node[1]
                #print("NODE",node,"\n")
                frontier.remove(node)
                solution.append(node)
                
        step_cost+=1       
        if(curr_state == goal_state):   #stop the loop if goal is reached
            goalReached = True
        
    print(solution,"\n")   
    return frontier,solution          



def main():
    #curr_state = [8,1,3,0,2,4,7,6,5]
    #goal_state = [1,2,3,8,0,4,7,6,5]

    curr_state ,goal_state = ReadIn("Sample_Input.txt")
    print("hi")
    # get file
    # get initial state and goal state using readState
                     
    #output = open("fname","w");
    for i in range(len(curr_state)):
        if (i % 3 == 0):
            print('\t')
        print(curr_state[i], end=" ")

    print('\t')

    for i in range(len(goal_state)):
        if (i % 3 == 0):
            print('\t')
        print(goal_state[i], end=" ")    

    frontier, solution = Asearch("MD",curr_state,goal_state)

    print('\n')
    print(len(solution))
    print(len(frontier))
    for item in (solution):
        print(item[0],end=" ")
    print("\t")
    for item in (solution):
        print(item[-1],end=" ")
    # output:
    # initial state
    # goal state
    # depth level d len(solutions)
    # total of nodes generated  len(frontier)
    # solution  solutions[0]
    # f(n) value    solutions[2]


main()
