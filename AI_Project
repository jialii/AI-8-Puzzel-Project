


from json.encoder import INFINITY
from tkinter import NS


h1Value = []
h2Value = []
curr_state = [8, 1, 3, 0, 2, 4, 7, 6, 5]

goal_state = [1, 2, 3, 8, 0, 4, 7, 6, 5]

def ReadIn(filename): #Takes an input file, and process the data into a list of number   
    f = open(filename, 'r')
    matrix = []
    for line in f:
        line = line.strip()
        nums = line.split(' ')
        if len(nums) < 3:
            continue
        for i in range(3):
            nums[i] = int(nums[i])
            matrix.append(nums[i])
    curr_state = [];
    goal_state = [];
    for i in range(18):
        if i<9:
            curr_state.append(matrix[i]);
        else:
            goal_state.append(matrix[i]);

    return curr_state, goal_state;


def MDistance(curr_state, goal_state):  # find the sum of manhattan distance of the node from
    # current 
    # `1`1state to goal state
    distance = 0
    for i,item in enumerate(curr_state): 
        if item != 0:
            curr_row,curr_col = int(i/ 3) , i % 3
            goal_row,goal_col = int(goal_state.index(item) /3),goal_state.index(item) % 3
            distance += abs(curr_row-goal_row) + abs(curr_col - goal_col)
    return distance

def NScore(curr_state, goal_state):
    P = MDistance(curr_state,goal_state)
    S = 0
    Nscore = 0
    order = [0,1,2,5,8,7,6,3]
    if curr_state[4] != goal_state[4]:
        S += 1
    for num in order:
        if (curr_state[num] != 0):
            if (curr_state[num] != goal_state[num]):
                S += 2
    Nscore = P + 3 * S
    return Nscore





def Asearch(h, curr_state, goal_state,goalReached=False):
    state_space = [curr_state];  #This makes sure there is no repeated states.  
    frontier = []
    solution = []
    min_fVal = INFINITY
    while goalReached == False :
        blank_pos = curr_state.index(0)
        if blank_pos in [1,2,4,5,7,8]: #Check for the possibility of moving blank space to the left
            potential_state = curr_state.copy()
            potential_state[blank_pos-1],potential_state[blank_pos] = potential_state[blank_pos], potential_state[blank_pos-1]
            if potential_state not in state_space:
                if (h == "MD"):
                    hVal = MDistance(curr_state,goal_state)
                else:
                    hVal = NScore(curr_state,goal_state)
                frontier.append(['L', potential_state,hVal])
                state_space.append(potential_state)
        if blank_pos in [0,1,3,4,6,7]: #Check for the possibility of moving blank space to the right
            potential_state = curr_state.copy()
            potential_state[blank_pos+1],potential_state[blank_pos] = potential_state[blank_pos], potential_state[blank_pos+1]
            if potential_state not in state_space:
                if (h == "MD"):
                    hVal = MDistance(curr_state,goal_state)
                else:
                    hVal = NScore(curr_state,goal_state)

                #SHOULD BE APPENDIG F VALUE INSTEAD OF H VALUE
                frontier.append(['R', potential_state,hVal])
                state_space.append(potential_state)
        if blank_pos in [0,1,2,3,4,5]: #Check for the possibility of moving blank space to below
            potential_state = curr_state.copy()
            potential_state[blank_pos+3],potential_state[blank_pos] = potential_state[blank_pos], potential_state[blank_pos+3]
            if potential_state not in state_space:
                if (h == "MD"):
                    hVal = MDistance(curr_state,goal_state)
                else:
                    hVal = NScore(curr_state,goal_state)
                frontier.append(['D', potential_state,hVal])
                state_space.append(potential_state)
        if blank_pos in [3,4,5,6,7,8]: #Check for the possibility of moving blank space to above
            potential_state = curr_state.copy()
            potential_state[blank_pos-3],potential_state[blank_pos] = potential_state[blank_pos], potential_state[blank_pos-3]
            if potential_state not in state_space:
                if (h == "MD"):
                    hVal = MDistance(curr_state,goal_state)
                else:
                    hVal = NScore(curr_state,goal_state)
                frontier.append(['U', potential_state,hVal])
                state_space.append(potential_state)
     
        
        for item in frontier:           #the state with minimum f value becomes current state
            if item[2] <= min_fVal:
                min_fVal = item[2]
                node = item             #store the node with smallest f value
                curr_state = item[1]
            if (item == frontier[-1]):    
                solution.append(node)
        if(curr_state == goal_state):   #stop the loop if goal is reached
            goalReached = True

    print(solution,'\n')
    print(frontier,'\n')   
    return frontier,solution          

'''
g = the movement cost to move from the starting point to a given square on the grid,
 following the path generated to get there. 
h = the estimated movement cost to move from that given square on the grid to the final 
destination. 
'''

def main():
    #print(curr_state)
      
    #print(goal_state)
    #a = MDistance(curr_state, goal_state)
    #b = NScore(curr_state, goal_state)
    initial_state, goal_state = ReadIn("Input1.txt")
    print (initial_state, goal_state)
    
    # get file
    # get initial state and goal state using readState
                     
    #output = open("fname","w");
    for i in range(len(curr_state)):
        if (i % 3 == 0):
            print('\t')
        print(curr_state[i], end=" ")

    print('\t')

    for i in range(len(goal_state)):
        if (i % 3 == 0):
            print('\t')
        print(goal_state[i], end=" ")    

    frontier, solution = Asearch("MD",curr_state,goal_state)

    print(len(solution))
    print(len(frontier))
    for item in (solution):
        print(item[0],end=" ")
    # output:
    # initial state
    # goal state
    # depth level d len(solutions)
    # total of nodes generated  len(frontier)
    # solution  solutions[0]
    # f(n) value    solutions[2]


main()
